{
  "hash": "ff3efd28bb37fb7dc96f1c5952a4b776",
  "result": {
    "markdown": "---\ntitle: \"Laboratorio 1\"\nsubtitle: \"Iniciación en R\"\neditor: visual\n---\n\n\n::: {.callout-note title=\"Conceptos claves\"}\n**Objeto**: contenedores de información que permiten al usuario realizar procedimientos numéricos, estadísticos, tabulaciones, entre otros.\n\n**Estructuras de datos**: son formatos de almacenamiento de información.\n\n**Funciones**: acciones que se realizan sobre los objetos y que producen un output. Por ejemplo, calcular la media sobre un vector sería: `mean(objeto)`\n\n**Coerción implícita**: proceso en el cual el lenguaje de programación define un ajuste por defecto.\n:::\n\nEn este taller nos enfocaremos en una introducción a R para el procesamiento datos. Para instala `R` y `RStudio` en tu computador puedes recurrir a los siguientes enlaces: \n\n- <https://cran.r-project.org/>\n- <https://posit.co/download/rstudio-desktop/>\n\nTambién puedes ver el siguiente video tutorial: <https://jd-conejeros.com/blog/2023/2023-03-15-r-rstudio/>\n\nRecuerda que puedes descargar y reproducir este proyecto directo en `RStudio` dando [Click aquí](/labs/TAD1_clase1_Taller.zip \"Lab 1 zip\") ⏎\n\n\n## Interactuando con R y RStudio\n\nLos comentarios que no se ejecutan como comandos, en otras palabras, es código no ejecutable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# : Comentarios que no se ejecutan como comandos\n# + : Sigue el comando en la próxima linea\n# ; : Para escribir más de una función en la misma línea\n```\n:::\n\n\n**Recomendación general:** todo lo que tenga que ver con procesamiento, análisis de bases de datos, entre otros, debe ser en un lenguaje estandarizado: sin tilde, ñ, caracteres especiales ni mayúsculas. Con esto se evitan bastantes problemas en un inicio. \n\nLos directorios son relevantes, pues nos entregan una ruta relativa a la cual acceder en nuestro computador. Para esto podemos usar las siguientes funciones en `R`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Consultar directorio de trabajo propio\ngetwd() \n\n# Fijar un directorio de trabajo\nsetwd(\"/Users/josedanielconejeros/Dropbox\") \n```\n:::\n\n\nAl inicio es complejo trabajar con rutas relativas, ya que implica a) uno debe investigar la ruta a la cual acceder en su computador y b) es fácil cometer errores de tipeo al escribir. Esto puede volver tortuoso el proceso al inicio, además fijar rutas relativas puede variar según el sistema operativo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Windows (\\)\nsetwd(\"\\Users\\josedanielconejeros\\Dropbox\")\n\n#Mac (/)\nsetwd(\"/Users/josedanielconejeros/Dropbox\")\n```\n:::\n\n\nLa mejor opción, será trabajar proyectos en `R`. Puedes crear proyectos de la siguiente manera: <video https://www.youtube.com/watch?v=FnkdlMIHYqQ>\n\n## Objetos en R\n\nEn términos generales, todos los elementos que maneja `R` son objetos: un valor numérico es un objeto, un vector es un objeto, una función es un objeto, una base de datos es un objeto, un gráfico es un objeto, etc. Los objetos son entes con datos almacenados, en palabras más sencillas,  contenedores de información que permiten al usuario realizar procedimientos numéricos, estadísticos, tabulaciones, entre otros.\n\nQue `R` sea un lenguaje de programación orientado a objetos (*Object-Oriented Programming*) significa que una misma función hace cosas distintas según la clase del objeto que recibe como argumento, pudiendo incluso no hacer nada (o producir un error) si se le pasan argumentos de una clase inadecuada.\n\nA continuación veremos algunos objetos de ejemplo: \n\n### Vectores numéricos \n\nPodemos considerar vectores de uno o varios elementos \n\n\n::: {.cell}\n\n```{.r .cell-code}\na1 <- c(1) #Vector de un elemento\na2 = c(1)\na3 <- c(1, \"hola\" , \"chao\" , 4) #Crear un vector números y carácteres\n```\n:::\n\n\nSi quisiera imprimir estos vectores puede escribir el nombre del objeto\n\n\n::: {.cell}\n\n```{.r .cell-code}\na1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\na2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n\n```{.r .cell-code}\na3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"    \"hola\" \"chao\" \"4\"   \n```\n:::\n:::\n\n\nPodemos construir secuencias de valores\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Secuencia de valores\n1:4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\n4:1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3 2 1\n```\n:::\n\n```{.r .cell-code}\n?seq\nseq(1, 4) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4\n```\n:::\n\n```{.r .cell-code}\nseq(4, 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 3 2 1\n```\n:::\n\n```{.r .cell-code}\n-1:2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  0  1  2\n```\n:::\n\n```{.r .cell-code}\nseq(-1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1  0  1  2\n```\n:::\n\n```{.r .cell-code}\nseq(from=2, to=8, by=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4 6 8\n```\n:::\n\n```{.r .cell-code}\nseq(0, 1, by=0.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n:::\n\n```{.r .cell-code}\nseq(0, 1, length=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667\n [8] 0.7777778 0.8888889 1.0000000\n```\n:::\n\n```{.r .cell-code}\nrep(0:1, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\n```\n:::\n\n```{.r .cell-code}\n?length # Para consultar argumentos de la función\n```\n:::\n\n\nLa importancia de los elementos que componen el objeto:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumeros_palabras <- c(1, \"hola\" , \"chao\" , 4)\nnumeros_palabras\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1\"    \"hola\" \"chao\" \"4\"   \n```\n:::\n\n```{.r .cell-code}\nsecuencia <- seq(0, 1, length=11)\nsecuencia\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsecuencia*numeros_palabras\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in secuencia * numeros_palabras: non-numeric argument to binary operator\n```\n:::\n:::\n\n\nEn este caso se produce porque está intentando multiplicar un vector de texto por uno numérico.\n\n::: {.callout-note title=\"Conceptos claves\"}\n**Coerción implícita**: proceso en el cual el lenguaje de programación define un ajuste por defecto. En este caso `c(1, \"hola\" , \"chao\" , 4)` asume por defecto que el vector será de caracteres. \n:::\n\nTambién podemos realizar operaciones aritméticas con vectores:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3, 4)/2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5 1.0 1.5 2.0\n```\n:::\n\n```{.r .cell-code}\n(1:4)/2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5 1.0 1.5 2.0\n```\n:::\n\n```{.r .cell-code}\n(1:4)*(4:1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6 6 4\n```\n:::\n\n```{.r .cell-code}\nc(1,2,3,4)*c(4,3,2,1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 6 6 4\n```\n:::\n\n```{.r .cell-code}\nc(1, 2 , 3 , 4) + c(4, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5 7 7\n```\n:::\n\n```{.r .cell-code}\nc(1, 2 , 3 , 4) + c(4, 3, 2) #Produce warning cuando no son múltiplos\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in c(1, 2, 3, 4) + c(4, 3, 2): longer object length is not a multiple\nof shorter object length\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5 5 5 8\n```\n:::\n:::\n\n\nPodemos realizar operaciones aritméticas con los objetos que componen esos vectores\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsecuencia <- seq(0, 1, length=11)\nsecuencia\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n```\n:::\n\n```{.r .cell-code}\nsecuencia <- secuencia*secuencia\nsecuencia\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.00 0.01 0.04 0.09 0.16 0.25 0.36 0.49 0.64 0.81 1.00\n```\n:::\n\n```{.r .cell-code}\nsecuencia^2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.0000 0.0001 0.0016 0.0081 0.0256 0.0625 0.1296 0.2401 0.4096 0.6561\n[11] 1.0000\n```\n:::\n\n```{.r .cell-code}\npromedio <- sum(secuencia)/11\npromedio\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.35\n```\n:::\n:::\n\n\n### String y factores\n\nTendremos instancias para profundizar en este tipo de objetos. Lo importante es recordar la coerción implíca subyacente a la hora de trabajar con textos. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Dummy\nsexo <- c(\"Femenino\", \"Masculino\", \"Masculino\", \"Femenino\")\nsexo[1:2] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Femenino\"  \"Masculino\"\n```\n:::\n\n```{.r .cell-code}\nsexo <- c(1,0,0,1)\nsexo[1:2] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 0\n```\n:::\n\n```{.r .cell-code}\n#Nominales\nanimales <- c(\"Elefante\", \"Jirafa\", \"Mono\", \"Caballo\")\nanimales[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Elefante\"\n```\n:::\n\n```{.r .cell-code}\n#Ordinal \nacuerdo <- c(\"Muy en Desacuerdo\", \"Desacuerdo\", \"Ni en desacuerdo\", \"Ni en desacuerdo\" , \n             \"Deacuerdo\", \"Muy deacuerdo\")\nacuerdo[5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Deacuerdo\"\n```\n:::\n:::\n\n\n**¿Cuál es el problema con estas variables?** \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(sexo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"numeric\"\n```\n:::\n:::\n\n\nEn ciertas operaciones, como la visualización de datos, contar con un formato más ordenado a la hora de construir una variable cualitativa es clave. Para esto utilizamos los **factores**. \n\nLos factores son variables que cuenta con etiquetas que permiten representar sus valores numéricos. A continuación un ejemplo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Debemos crear factores numéricos con etiquetas\nsexo <- factor(c(0,1,1,0))\nsexo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 1 1 0\nLevels: 0 1\n```\n:::\n\n```{.r .cell-code}\n#Generamos etiquetas\nsexo <- factor(sexo, labels = c(\"Mujer\", \"Hombre\"))\nsexo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Mujer  Hombre Hombre Mujer \nLevels: Mujer Hombre\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(sexo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"factor\"\n```\n:::\n:::\n\n\n## Matrices, dataframes y listas\n\n### Matrices \n\nLas matrices son arreglos bidimensionales (filas, columnas) y solo cuentan con elementos de la misma naturaleza. Por ejemplo, la siguiente matriz cuenta con solo elementos de tipo numérico: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Ejemplo de matriz\nmatrix(1:9,3,3) #Matriz de 3filasx3columnas con valores del 1 al 9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n:::\n\n\nTambién podemos considerar las matrices sobre objetos y realizar acciones sobre ellas: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:9,3,3)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n:::\n\n```{.r .cell-code}\n# Podemos ver las dimensiones de la matriz (fila, columna)\ndim(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3 3\n```\n:::\n:::\n\n\nConstruyamos las siguientes matrices: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Podemos definir objetos como matrices\ny <- matrix(1:8,2,4,byrow = FALSE) #Genera una matriz con 2 filas y 4 columnas\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\ndim(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n\n```{.r .cell-code}\nz <- matrix(1:8,2,4,byrow = TRUE) #Genera la matriz completándola por filas\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    2    3    4\n[2,]    5    6    7    8\n```\n:::\n\n```{.r .cell-code}\ndim(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\nA continuación aplicaremos operaciones matemáticas con dichas matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Suma\nsum <- y + z\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    5    8   11\n[2,]    7   10   13   16\n```\n:::\n\n```{.r .cell-code}\n# Resta\ndiff <- y - z\ndiff\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    0    1    2    3\n[2,]   -3   -2   -1    0\n```\n:::\n\n```{.r .cell-code}\n# Transponer\nt(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n[4,]    7    8\n```\n:::\n\n```{.r .cell-code}\n# Multiplicar/dividir por un escalar\ny*2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n```\n:::\n\n```{.r .cell-code}\n2*y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    2    6   10   14\n[2,]    4    8   12   16\n```\n:::\n\n```{.r .cell-code}\ny/2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]  0.5  1.5  2.5  3.5\n[2,]  1.0  2.0  3.0  4.0\n```\n:::\n\n```{.r .cell-code}\n# Multiplicación elemento a elemento\ny*z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    6   15   28\n[2,]   10   24   42   64\n```\n:::\n:::\n\n\nLa multiplicación de matrices no es elemento a elemento. En este caso `R` tiene operadores especiales para la matemática matricial:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny %*% z\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in y %*% z: non-conformable arguments\n```\n:::\n:::\n\n\n**¿Cuál es el error?** El número de columnas de la primera matriz debe ser igual al número de filas de la segunda. Construímos nuestra matriz cuadrada:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny # Matriz original\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n```\n:::\n\n```{.r .cell-code}\ny_cuadrada <- y[1:2,1:2] # Matriz cuadrada\n# Multiplicación de matrices\ny_cuadrada %*% z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4]\n[1,]   16   20   24   28\n[2,]   22   28   34   40\n```\n:::\n:::\n\nEl determinante de una matriz es se obtiene al restar la multiplicación de los elementos de la diagonal principal de la matriz y la multiplicación de los elementos de la diagonal secundaria de la misma matriz. Esto nos será útil pues permite saber si estamos frente a una matriz singular ($det=0$) o no singular ($det\\neq0$). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Determinante\ndet(y_cuadrada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -2\n```\n:::\n:::\n\n\nLos determinantes son esenciales cuando queremos encontrar la matriz inversa y con esto aplicar técnicas de modelamiento estadístico como la regresión lineal ($\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{Y}$).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_invertida <- solve(y_cuadrada)\ny_invertida\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n```\n:::\n:::\n\n\nSi multiplicamos la matriz original por la inversa obtenemos la identidad: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Comprobamos\ny_cuadrada %*% y_invertida\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n```\n:::\n:::\n\n\nOtras operaciones útiles con matrices: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Rango de una matriz\nqr(y_cuadrada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$qr\n           [,1]       [,2]\n[1,] -2.2360680 -4.9193496\n[2,]  0.8944272 -0.8944272\n\n$rank\n[1] 2\n\n$qraux\n[1] 1.4472136 0.8944272\n\n$pivot\n[1] 1 2\n\nattr(,\"class\")\n[1] \"qr\"\n```\n:::\n\n```{.r .cell-code}\nqr(y_cuadrada)$rank\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\n# Diagonal de una matriz\ny_cuadrada\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n```\n:::\n\n```{.r .cell-code}\ndiag(y_cuadrada)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 4\n```\n:::\n\n```{.r .cell-code}\n# Construímos la matriz identidad\ndiag(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    0    0    0    0\n[2,]    0    1    0    0    0\n[3,]    0    0    1    0    0\n[4,]    0    0    0    1    0\n[5,]    0    0    0    0    1\n```\n:::\n:::\n\n\nPodemos construir una matriz de datos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generamos vectores de información\nedad <- c(23, 45, 67, 89)\nsexo <- c(1, 0, 1, 0)\npeso <- c(80, 60, 70, 50)\naltura <- c(180, 160, 200, 140)\npromedio <- mean(altura) # Vamos a guardarlo para después\n```\n:::\n\n\nConstruímos las matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Unimos las matrices por separado\nmatriz_a <- cbind(edad, sexo) # Columnas\nmatriz_a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     edad sexo\n[1,]   23    1\n[2,]   45    0\n[3,]   67    1\n[4,]   89    0\n```\n:::\n\n```{.r .cell-code}\nmatriz_b <- cbind(peso, altura)\nmatriz_b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     peso altura\n[1,]   80    180\n[2,]   60    160\n[3,]   70    200\n[4,]   50    140\n```\n:::\n\n```{.r .cell-code}\n# Combinar matrices\nmatriz <- cbind(matriz_a, matriz_b)\nmatriz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     edad sexo peso altura\n[1,]   23    1   80    180\n[2,]   45    0   60    160\n[3,]   67    1   70    200\n[4,]   89    0   50    140\n```\n:::\n\n```{.r .cell-code}\nmatriz[1,2] #Podemos ver el elemento 1 de la columna 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsexo \n   1 \n```\n:::\n:::\n\n\nMás detalles sobre matrices: \n\nBates, Douglas, Martin Maechler, and Mikael Jagan. 2022. Matrix: Sparse and Dense Matrix Classes and Methods. [https://cran.r-project.org/web/packages/Matrix/Matrix.pdf](https://cran.r-project.org/web/packages/Matrix/Matrix.pdf) ⏎\n\n### Marcos de datos\n\nUn marco de datos (O *dataframe*) es un objeto bidimensional, pero a diferencia de las matrices (numéricas), pueden almacenar objetos de distinta naturaleza (alfanuméricos). En términos más precisos es un arreglo de vectores ordenados por columnas. Podemos transformar facilmente nuestra matriz en un marco de datos. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(matriz)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n\n```{.r .cell-code}\n# Transformamos a un marco de datos\ndata <- as.data.frame(matriz)\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\nDada su estructura bidimensional, podemos extraer información desde los marcos de datos aplicando la lógica `[fila, columna]`. Veamos un ejemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata[1] # Columna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  edad\n1   23\n2   45\n3   67\n4   89\n```\n:::\n\n```{.r .cell-code}\ndata[\"edad\"] # Columna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  edad\n1   23\n2   45\n3   67\n4   89\n```\n:::\n\n```{.r .cell-code}\ndata[1,1] # Fila, columna\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23\n```\n:::\n\n```{.r .cell-code}\ndata[,1] # Fila\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23 45 67 89\n```\n:::\n:::\n\n\nUna forma de acceder a las variables de una marco de datos es aplicar un indexador `$`, por ejemplo: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata$edad\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 23 45 67 89\n```\n:::\n:::\n\n\nEsto es factible ya que el marco de datos no es más que un arreglo de vectores. \n\n### Listas \n\nLa lista representa el siguiente nivel de complejidad en las estructuras de datos que R es capaz de manejar. Podemos entender una lista como un contenedor de objetos que pueden ser de cualquier clase: números, vectores, matrices, funciones, data.frames, incluso otras listas. Una lista puede contener a la vez varios de estos objetos, que pueden ser además de distintas dimensiones.\n\nVeamos un ejemplo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Creamos una lista\n#matriz, valor, vector numérico, vetor de caracteres\nobjeto <- list(matriz, promedio, sexo, animales) \nobjeto\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     edad sexo peso altura\n[1,]   23    1   80    180\n[2,]   45    0   60    160\n[3,]   67    1   70    200\n[4,]   89    0   50    140\n\n[[2]]\n[1] 170\n\n[[3]]\n[1] 1 0 1 0\n\n[[4]]\n[1] \"Elefante\" \"Jirafa\"   \"Mono\"     \"Caballo\" \n```\n:::\n:::\n\n\nPodemos acceder a la información de las listas de variables maneras:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjeto[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     edad sexo peso altura\n[1,]   23    1   80    180\n[2,]   45    0   60    160\n[3,]   67    1   70    200\n[4,]   89    0   50    140\n```\n:::\n:::\n\n\nTambién es posible realizar operaciones con las listas: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjeto[[1]]*2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     edad sexo peso altura\n[1,]   46    2  160    360\n[2,]   90    0  120    320\n[3,]  134    2  140    400\n[4,]  178    0  100    280\n```\n:::\n:::\n\n\nEstas estructuras de datos serán bastante útiles a la hora de extraer información de funciones, realizar procesos iterativos y la extracción de datos desde la web. \n\n## Operadores en R \n\nLos operadores en R nos permiten complementar las acciones que estamos realizando sobre los objetos. Los más utilizados son: \n\n:::: {.columns}\n\n::: {.column width=\"25%\"}\n\n**Operadores lógicos**\n\n- `&` = Y \n- `|` = O\n- `!` = Negación\n- `~` = Negación\n\n:::\n\n::: {.column width=\"25%\"}\n\n**Operadores aritméticos**\n\n- `+` = Suma\n- `-` = Resta\n- `*` = Multiplicación \n- `/` = División\n- `^` = Potencia\n\n:::\n\n::: {.column width=\"25%\"}\n\n**Operadores relacionales**\n\n- `>` = Mayor que \n- `<` = Menor que\n- `>=` = Mayor o igual que \n- `<=` = Menor o igual que \n- `==` = Igual\n- `!=` = No igual \n- `~=` = No igual\n\n:::\n\n::: {.column width=\"50%\"}\n\n**Otros**\n\n- `NA` = Valor perdido\n\n:::\n\n::::\n\nVeamos algunos ejemplos: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definamos valores\na <- 3\nb <- 2.999\nc <- 1\n\n# Apliquemos las condiciones\nc != a\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\na == b  # ¿Qué pasa si solo uso =?\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na > b \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nb < c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nTrate de identificar los valores resultantes que obtuvo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na > b & b < c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n\n```{.r .cell-code}\na > b | b < c\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n## Funciones y argumentos\n\n### Funciones\n\nLas funciones son acciones que se realizan sobre los objetos en `R`, operan bajo la siguiente lógica:\n\n![Lógica de funciones en R](img/log_r.png){width=750}\n\nVeamos algunos ejemplos:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definamos objetos\na <- seq(1:100)\nb <- c(\"uno\", \"dos\", \"tres\")\n\n# Apliquemos las funciones \nlog(\"a\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log(\"a\"): non-numeric argument to mathematical function\n```\n:::\n\n```{.r .cell-code}\nlog(b)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log(b): non-numeric argument to mathematical function\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apliquemos sobre los objetos\nlog(a) # Por DEFAULT es logaritmo natural, en base a euler 2,718.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 1.7917595 1.9459101\n  [8] 2.0794415 2.1972246 2.3025851 2.3978953 2.4849066 2.5649494 2.6390573\n [15] 2.7080502 2.7725887 2.8332133 2.8903718 2.9444390 2.9957323 3.0445224\n [22] 3.0910425 3.1354942 3.1780538 3.2188758 3.2580965 3.2958369 3.3322045\n [29] 3.3672958 3.4011974 3.4339872 3.4657359 3.4965076 3.5263605 3.5553481\n [36] 3.5835189 3.6109179 3.6375862 3.6635616 3.6888795 3.7135721 3.7376696\n [43] 3.7612001 3.7841896 3.8066625 3.8286414 3.8501476 3.8712010 3.8918203\n [50] 3.9120230 3.9318256 3.9512437 3.9702919 3.9889840 4.0073332 4.0253517\n [57] 4.0430513 4.0604430 4.0775374 4.0943446 4.1108739 4.1271344 4.1431347\n [64] 4.1588831 4.1743873 4.1896547 4.2046926 4.2195077 4.2341065 4.2484952\n [71] 4.2626799 4.2766661 4.2904594 4.3040651 4.3174881 4.3307333 4.3438054\n [78] 4.3567088 4.3694479 4.3820266 4.3944492 4.4067192 4.4188406 4.4308168\n [85] 4.4426513 4.4543473 4.4659081 4.4773368 4.4886364 4.4998097 4.5108595\n [92] 4.5217886 4.5325995 4.5432948 4.5538769 4.5643482 4.5747110 4.5849675\n [99] 4.5951199 4.6051702\n```\n:::\n\n```{.r .cell-code}\nlog(a, base=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 0.0000000 0.3010300 0.4771213 0.6020600 0.6989700 0.7781513 0.8450980\n  [8] 0.9030900 0.9542425 1.0000000 1.0413927 1.0791812 1.1139434 1.1461280\n [15] 1.1760913 1.2041200 1.2304489 1.2552725 1.2787536 1.3010300 1.3222193\n [22] 1.3424227 1.3617278 1.3802112 1.3979400 1.4149733 1.4313638 1.4471580\n [29] 1.4623980 1.4771213 1.4913617 1.5051500 1.5185139 1.5314789 1.5440680\n [36] 1.5563025 1.5682017 1.5797836 1.5910646 1.6020600 1.6127839 1.6232493\n [43] 1.6334685 1.6434527 1.6532125 1.6627578 1.6720979 1.6812412 1.6901961\n [50] 1.6989700 1.7075702 1.7160033 1.7242759 1.7323938 1.7403627 1.7481880\n [57] 1.7558749 1.7634280 1.7708520 1.7781513 1.7853298 1.7923917 1.7993405\n [64] 1.8061800 1.8129134 1.8195439 1.8260748 1.8325089 1.8388491 1.8450980\n [71] 1.8512583 1.8573325 1.8633229 1.8692317 1.8750613 1.8808136 1.8864907\n [78] 1.8920946 1.8976271 1.9030900 1.9084850 1.9138139 1.9190781 1.9242793\n [85] 1.9294189 1.9344985 1.9395193 1.9444827 1.9493900 1.9542425 1.9590414\n [92] 1.9637878 1.9684829 1.9731279 1.9777236 1.9822712 1.9867717 1.9912261\n [99] 1.9956352 2.0000000\n```\n:::\n\n```{.r .cell-code}\nlog(2.718) # Cercano a 1 porque euler elevado a 1 = euler\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.9998963\n```\n:::\n\n```{.r .cell-code}\nlog(100, base=10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nlog10(100) # Forma equivalente de lo anterior\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n\n```{.r .cell-code}\nlog10(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] 0.0000000 0.3010300 0.4771213 0.6020600 0.6989700 0.7781513 0.8450980\n  [8] 0.9030900 0.9542425 1.0000000 1.0413927 1.0791812 1.1139434 1.1461280\n [15] 1.1760913 1.2041200 1.2304489 1.2552725 1.2787536 1.3010300 1.3222193\n [22] 1.3424227 1.3617278 1.3802112 1.3979400 1.4149733 1.4313638 1.4471580\n [29] 1.4623980 1.4771213 1.4913617 1.5051500 1.5185139 1.5314789 1.5440680\n [36] 1.5563025 1.5682017 1.5797836 1.5910646 1.6020600 1.6127839 1.6232493\n [43] 1.6334685 1.6434527 1.6532125 1.6627578 1.6720979 1.6812412 1.6901961\n [50] 1.6989700 1.7075702 1.7160033 1.7242759 1.7323938 1.7403627 1.7481880\n [57] 1.7558749 1.7634280 1.7708520 1.7781513 1.7853298 1.7923917 1.7993405\n [64] 1.8061800 1.8129134 1.8195439 1.8260748 1.8325089 1.8388491 1.8450980\n [71] 1.8512583 1.8573325 1.8633229 1.8692317 1.8750613 1.8808136 1.8864907\n [78] 1.8920946 1.8976271 1.9030900 1.9084850 1.9138139 1.9190781 1.9242793\n [85] 1.9294189 1.9344985 1.9395193 1.9444827 1.9493900 1.9542425 1.9590414\n [92] 1.9637878 1.9684829 1.9731279 1.9777236 1.9822712 1.9867717 1.9912261\n [99] 1.9956352 2.0000000\n```\n:::\n:::\n\n\n\n### Argumentos\n\nLos argumentos de una función no son más que configuraciones particulares de la función para que realice la acción que deseamos, podemos consultarlas de la siguiente manera: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(\"log\") #Para saber argumentos (elementos de la función)\n?log\nargs(\"log\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (x, base = exp(1)) \nNULL\n```\n:::\n\n```{.r .cell-code}\n?sum\nargs(\"sum\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (..., na.rm = FALSE) \nNULL\n```\n:::\n:::\n\n\nVeamos un ejemplo práctico en donde sea útil especificar un argumento:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Definimos un objeto con un elemento missing \na <- c(1, 2, NA, 4)\n# Aplicamos un objeto \nsum(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nEn este caso retorna un `NA` ya que nuestro vector tiene un elemento que es missing value, por lo que ante ese contexto la programación tiene definido por defecto retornar un `NA`. Podemos cambiar esto especificando el argumento `na.rm=TRUE` de la siguiente manera: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(a, na.rm=TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n:::\n\n\nAhora obtuvimos el resultado, pues le dijimos al `R` que sume los valores  asumiendo como  verdadera la orden: *remover los valores NA*\n\n## Ejercicio propuesto \n\nRevise la siguiente función y responda las preguntas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun3 <- function(x){ifelse(-10 <= x  & x < -5, x*2-1,\n                           ifelse(-5<=x & x < 0, (3*x-2)/(x+1), \n                                  ifelse(1<=x & x < 5, exp(x+1), \"Valor no está en el dominio\"))) \n}\n```\n:::\n\n\na. Evalue la función en los siguientes valores: -11, -7, -2, 0, 2 y 6. Interprete sus resultados.\n\nb. ¿Qué pasa si aplico la función en el valor 6,5 y si ahora aplica \"6,5\" (incluyendo comillas). Explique la diferencia.\n\nc. ¿Qué ocurre con la función en el valor 6? Solucione el problema. \n\nd. Genere un objeto con una secuencia entre 1 a 5 y evalue la función corregida en c). Muestre sus valores.\n\n\n",
    "supporting": [
      "lab-1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}